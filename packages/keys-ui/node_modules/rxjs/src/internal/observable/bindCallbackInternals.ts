import { SchedulerLike } from '../types';
import { isScheduler } from '../util/isScheduler';
import { Observable } from '../Observable';
import { subscribeOn } from '../operators/subscribeOn';
import { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';
import { observeOn } from '../operators/observeOn';
import { AsyncSubject } from '../AsyncSubject';

export function bindCallbackInternals(
  isNodeStyle: boolean,
  callbackFunc: any,
  resultSelector?: any,
  scheduler?: SchedulerLike
): (...args: any[]) => Observable<unknown> {
  if (resultSelector) {
    if (isScheduler(resultSelector)) {
      scheduler = resultSelector;
    } else {
      return function (this: any, ...args: any[]) {
        return (bindCallbackInternals(isNodeStyle, callbackFunc, scheduler) as any)
          .apply(this, args)
          .pipe(mapOneOrManyArgs(resultSelector as any));
      };
    }
  }

  if (scheduler) {
    return function (this: any, ...args: any[]) {
      return (bindCallbackInternals(isNodeStyle, callbackFunc) as any)
        .apply(this, args)
        .pipe(subscribeOn(scheduler!), observeOn(scheduler!));
    };
  }

  return function (this: any, ...args: any[]): Observable<any> {
    const subject = new AsyncSubject<any>();

    let uninitialized = true;
    return new Observable((subscriber) => {
      const subs = subject.subscribe(subscriber);

      if (uninitialized) {
        uninitialized = false;
        let isAsync = false;

        let isComplete = false;

        callbackFunc.apply(
          this,
          [
            ...args,
            (...results: any[]) => {
              if (isNodeStyle) {
                const err = results.shift();
                if (err != null) {
                  subject.error(err);
                  return;
                }
              }
              subject.next(1 < results.length ? results : results[0]);
              isComplete = true;
              if (isAsync) {
                subject.complete();
              }
            },
          ]
        );
        if (isComplete) {
          subject.complete();
        }

        isAsync = true;
      }

      return subs;
    });
  };
}
