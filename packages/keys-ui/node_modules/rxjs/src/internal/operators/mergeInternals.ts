import { Observable } from '../Observable';
import { innerFrom } from '../observable/innerFrom';
import { Subscriber } from '../Subscriber';
import { ObservableInput, SchedulerLike } from '../types';
import { executeSchedule } from '../util/executeSchedule';
import { createOperatorSubscriber } from './OperatorSubscriber';

/**
 * A process embodying the general "merge" strategy. This is used in
 * `mergeMap` and `mergeScan` because the logic is otherwise nearly identical.
 * @param source The original source observable
 * @param subscriber The consumer subscriber
 * @param project The projection function to get our inner sources
 * @param concurrent The number of concurrent inner subscriptions
 * @param onBeforeNext Additional logic to apply before nexting to our consumer
 * @param expand If `true` this will perform an "expand" strategy, which differs only
 * in that it recurses, and the inner subscription must be schedule-able.
 * @param innerSubScheduler A scheduler to use to schedule inner subscriptions,
 * this is to support the expand strategy, mostly, and should be deprecated
 */
export function mergeInternals<T, R>(
  source: Observable<T>,
  subscriber: Subscriber<R>,
  project: (value: T, index: number) => ObservableInput<R>,
  concurrent: number,
  onBeforeNext?: (innerValue: R) => void,
  expand?: boolean,
  innerSubScheduler?: SchedulerLike,
  additionalFinalizer?: () => void
) {
  const buffer: T[] = [];
  let active = 0;
  let index = 0;
  let isComplete = false;

  /**
   * Checks to see if we can complete our result or not.
   */
  const checkComplete = () => {
    if (isComplete && !buffer.length && !active) {
      subscriber.complete();
    }
  };

  const outerNext = (value: T) => (active < concurrent ? doInnerSub(value) : buffer.push(value));

  const doInnerSub = (value: T) => {
    expand && subscriber.next(value as any);

    active++;

    let innerComplete = false;

    innerFrom(project(value, index++)).subscribe(
      createOperatorSubscriber(
        subscriber,
        (innerValue) => {
          onBeforeNext?.(innerValue);

          if (expand) {
            outerNext(innerValue as any);
          } else {
            subscriber.next(innerValue);
          }
        },
        () => {
          innerComplete = true;
        },
        undefined,
        () => {
          if (innerComplete) {
            try {
              active--;
              while (buffer.length && active < concurrent) {
                const bufferedValue = buffer.shift()!;
                if (innerSubScheduler) {
                  executeSchedule(subscriber, innerSubScheduler, () => doInnerSub(bufferedValue));
                } else {
                  doInnerSub(bufferedValue);
                }
              }
              checkComplete();
            } catch (err) {
              subscriber.error(err);
            }
          }
        }
      )
    );
  };

  source.subscribe(
    createOperatorSubscriber(subscriber, outerNext, () => {
      isComplete = true;
      checkComplete();
    })
  );

  return () => {
    additionalFinalizer?.();
  };
}
